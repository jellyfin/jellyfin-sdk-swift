//
// MediaInfoAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
#if canImport(Combine)
import Combine
#endif

open class MediaInfoAPI {
    /**
     Closes a media source.
     
     - parameter liveStreamId: (query) The livestream id. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func closeLiveStream(liveStreamId: String, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            closeLiveStreamWithRequestBuilder(liveStreamId: liveStreamId).execute(apiResponseQueue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Closes a media source.
     - POST /LiveStreams/Close
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter liveStreamId: (query) The livestream id. 
     - returns: RequestBuilder<Void> 
     */
    open class func closeLiveStreamWithRequestBuilder(liveStreamId: String) -> RequestBuilder<Void> {
        let urlPath = "/LiveStreams/Close"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "liveStreamId": liveStreamId.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = JellyfinAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Tests the network with a request with the size of the bitrate.
     
     - parameter size: (query) The bitrate. Defaults to 102400. (optional, default to 102400)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<URL, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getBitrateTestBytes(size: Int? = nil, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<URL, Error> {
        return Future<URL, Error>.init { promise in
            getBitrateTestBytesWithRequestBuilder(size: size).execute(apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Tests the network with a request with the size of the bitrate.
     - GET /Playback/BitrateTest
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter size: (query) The bitrate. Defaults to 102400. (optional, default to 102400)
     - returns: RequestBuilder<URL> 
     */
    open class func getBitrateTestBytesWithRequestBuilder(size: Int? = nil) -> RequestBuilder<URL> {
        let urlPath = "/Playback/BitrateTest"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "size": size?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<URL>.Type = JellyfinAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Gets live playback media info for an item.
     
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<PlaybackInfoResponse, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlaybackInfo(itemId: UUID, userId: UUID, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<PlaybackInfoResponse, Error> {
        return Future<PlaybackInfoResponse, Error>.init { promise in
            getPlaybackInfoWithRequestBuilder(itemId: itemId, userId: userId).execute(apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Gets live playback media info for an item.
     - GET /Items/{itemId}/PlaybackInfo
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. 
     - returns: RequestBuilder<PlaybackInfoResponse> 
     */
    open class func getPlaybackInfoWithRequestBuilder(itemId: UUID, userId: UUID) -> RequestBuilder<PlaybackInfoResponse> {
        var urlPath = "/Items/{itemId}/PlaybackInfo"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        urlPath = urlPath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "userId": userId.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<PlaybackInfoResponse>.Type = JellyfinAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Gets live playback media info for an item.
     
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter liveStreamId: (query) The livestream id. (optional)
     - parameter autoOpenLiveStream: (query) Whether to auto open the livestream. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter enableTranscoding: (query) Whether to enable transcoding. Default: true. (optional)
     - parameter allowVideoStreamCopy: (query) Whether to allow to copy the video stream. Default: true. (optional)
     - parameter allowAudioStreamCopy: (query) Whether to allow to copy the audio stream. Default: true. (optional)
     - parameter playbackInfoDto: (body) The playback info. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<PlaybackInfoResponse, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPostedPlaybackInfo(itemId: UUID, userId: UUID? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, mediaSourceId: String? = nil, liveStreamId: String? = nil, autoOpenLiveStream: Bool? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, enableTranscoding: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, playbackInfoDto: PlaybackInfoDto? = nil, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<PlaybackInfoResponse, Error> {
        return Future<PlaybackInfoResponse, Error>.init { promise in
            getPostedPlaybackInfoWithRequestBuilder(itemId: itemId, userId: userId, maxStreamingBitrate: maxStreamingBitrate, startTimeTicks: startTimeTicks, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, maxAudioChannels: maxAudioChannels, mediaSourceId: mediaSourceId, liveStreamId: liveStreamId, autoOpenLiveStream: autoOpenLiveStream, enableDirectPlay: enableDirectPlay, enableDirectStream: enableDirectStream, enableTranscoding: enableTranscoding, allowVideoStreamCopy: allowVideoStreamCopy, allowAudioStreamCopy: allowAudioStreamCopy, playbackInfoDto: playbackInfoDto).execute(apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Gets live playback media info for an item.
     - POST /Items/{itemId}/PlaybackInfo
     - For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.  Query parameters are obsolete.
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter itemId: (path) The item id. 
     - parameter userId: (query) The user id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter mediaSourceId: (query) The media source id. (optional)
     - parameter liveStreamId: (query) The livestream id. (optional)
     - parameter autoOpenLiveStream: (query) Whether to auto open the livestream. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter enableTranscoding: (query) Whether to enable transcoding. Default: true. (optional)
     - parameter allowVideoStreamCopy: (query) Whether to allow to copy the video stream. Default: true. (optional)
     - parameter allowAudioStreamCopy: (query) Whether to allow to copy the audio stream. Default: true. (optional)
     - parameter playbackInfoDto: (body) The playback info. (optional)
     - returns: RequestBuilder<PlaybackInfoResponse> 
     */
    open class func getPostedPlaybackInfoWithRequestBuilder(itemId: UUID, userId: UUID? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, mediaSourceId: String? = nil, liveStreamId: String? = nil, autoOpenLiveStream: Bool? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, enableTranscoding: Bool? = nil, allowVideoStreamCopy: Bool? = nil, allowAudioStreamCopy: Bool? = nil, playbackInfoDto: PlaybackInfoDto? = nil) -> RequestBuilder<PlaybackInfoResponse> {
        var urlPath = "/Items/{itemId}/PlaybackInfo"
        let itemIdPreEscape = "\(APIHelper.mapValueToPathItem(itemId))"
        let itemIdPostEscape = itemIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        urlPath = urlPath.replacingOccurrences(of: "{itemId}", with: itemIdPostEscape, options: .literal, range: nil)
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: playbackInfoDto)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "userId": userId?.encodeToJSON(),
            "maxStreamingBitrate": maxStreamingBitrate?.encodeToJSON(),
            "startTimeTicks": startTimeTicks?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "maxAudioChannels": maxAudioChannels?.encodeToJSON(),
            "mediaSourceId": mediaSourceId?.encodeToJSON(),
            "liveStreamId": liveStreamId?.encodeToJSON(),
            "autoOpenLiveStream": autoOpenLiveStream?.encodeToJSON(),
            "enableDirectPlay": enableDirectPlay?.encodeToJSON(),
            "enableDirectStream": enableDirectStream?.encodeToJSON(),
            "enableTranscoding": enableTranscoding?.encodeToJSON(),
            "allowVideoStreamCopy": allowVideoStreamCopy?.encodeToJSON(),
            "allowAudioStreamCopy": allowAudioStreamCopy?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<PlaybackInfoResponse>.Type = JellyfinAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Opens a media source.
     
     - parameter openToken: (query) The open token. (optional)
     - parameter userId: (query) The user id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter itemId: (query) The item id. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter openLiveStreamDto: (body) The open live stream dto. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: AnyPublisher<LiveStreamResponse, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func openLiveStream(openToken: String? = nil, userId: UUID? = nil, playSessionId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, itemId: UUID? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, openLiveStreamDto: OpenLiveStreamDto? = nil, apiResponseQueue: DispatchQueue = JellyfinAPI.apiResponseQueue) -> AnyPublisher<LiveStreamResponse, Error> {
        return Future<LiveStreamResponse, Error>.init { promise in
            openLiveStreamWithRequestBuilder(openToken: openToken, userId: userId, playSessionId: playSessionId, maxStreamingBitrate: maxStreamingBitrate, startTimeTicks: startTimeTicks, audioStreamIndex: audioStreamIndex, subtitleStreamIndex: subtitleStreamIndex, maxAudioChannels: maxAudioChannels, itemId: itemId, enableDirectPlay: enableDirectPlay, enableDirectStream: enableDirectStream, openLiveStreamDto: openLiveStreamDto).execute(apiResponseQueue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif

    /**
     Opens a media source.
     - POST /LiveStreams/Open
     - API Key:
       - type: apiKey X-Emby-Authorization 
       - name: CustomAuthentication
     - parameter openToken: (query) The open token. (optional)
     - parameter userId: (query) The user id. (optional)
     - parameter playSessionId: (query) The play session id. (optional)
     - parameter maxStreamingBitrate: (query) The maximum streaming bitrate. (optional)
     - parameter startTimeTicks: (query) The start time in ticks. (optional)
     - parameter audioStreamIndex: (query) The audio stream index. (optional)
     - parameter subtitleStreamIndex: (query) The subtitle stream index. (optional)
     - parameter maxAudioChannels: (query) The maximum number of audio channels. (optional)
     - parameter itemId: (query) The item id. (optional)
     - parameter enableDirectPlay: (query) Whether to enable direct play. Default: true. (optional)
     - parameter enableDirectStream: (query) Whether to enable direct stream. Default: true. (optional)
     - parameter openLiveStreamDto: (body) The open live stream dto. (optional)
     - returns: RequestBuilder<LiveStreamResponse> 
     */
    open class func openLiveStreamWithRequestBuilder(openToken: String? = nil, userId: UUID? = nil, playSessionId: String? = nil, maxStreamingBitrate: Int? = nil, startTimeTicks: Int64? = nil, audioStreamIndex: Int? = nil, subtitleStreamIndex: Int? = nil, maxAudioChannels: Int? = nil, itemId: UUID? = nil, enableDirectPlay: Bool? = nil, enableDirectStream: Bool? = nil, openLiveStreamDto: OpenLiveStreamDto? = nil) -> RequestBuilder<LiveStreamResponse> {
        let urlPath = "/LiveStreams/Open"
        let URLString = JellyfinAPI.basePath + urlPath
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: openLiveStreamDto)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "openToken": openToken?.encodeToJSON(),
            "userId": userId?.encodeToJSON(),
            "playSessionId": playSessionId?.encodeToJSON(),
            "maxStreamingBitrate": maxStreamingBitrate?.encodeToJSON(),
            "startTimeTicks": startTimeTicks?.encodeToJSON(),
            "audioStreamIndex": audioStreamIndex?.encodeToJSON(),
            "subtitleStreamIndex": subtitleStreamIndex?.encodeToJSON(),
            "maxAudioChannels": maxAudioChannels?.encodeToJSON(),
            "itemId": itemId?.encodeToJSON(),
            "enableDirectPlay": enableDirectPlay?.encodeToJSON(),
            "enableDirectStream": enableDirectStream?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<LiveStreamResponse>.Type = JellyfinAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
